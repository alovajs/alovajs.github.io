---
title: method metadata
sidebar_position: 35
---

:::info version requirements

v2.7.0+

:::

Method instances run through the entire request life cycle of alova, and there are a large number of different method instances in the project. Sometimes we need to add additional information to specific method instances in order to identify them or pass additional information Wait, at this point, we need to use method metadata.

## Use metadata to identify identities

### Use the identity before the request

For example, most of the interfaces in your project need to be accompanied by `token` for each request, but there are still some interfaces that do not need to be verified, and you may handle them uniformly in the global `beforeRequest` function.

```javascript
const nonvalidateRequiredApi = [
  '/api/url1',
  '/api/url2',
  '/api/url3'
  //...
];

createAlova({
  beforeRequest(method) {
    if (!nonvalidateRequiredApi.includes(method.url)) {
      method.config.headers.token = '...';
    }
  }
});
```

This will cause the following two problems:

1. The information is not aggregated with the method instance, and the maintainability is worse;
2. Coding is more troublesome;

To solve these two problems, we will use metadata to identify a specific method instance when it is created.

**Step 1: Define metadata when creating a method instance**

```javascript
const loginAPI = (username, password) => {
  const methodInstance = alovaInst.Post('/login', {
    username,
    password
  });
  methodInstance.meta = {
    ignoreToken: true
  };
  return methodInstance;
};
```

**Step 2: Use metadata as the basis for judgment in `beforeRequest`**

```javascript
createAlova({
  //...
  beforeRequest(method) {
    if (!method.meta?.ignoreToken) {
      method.config.headers.token = '...';
    }
  }
});
```

### Use identity after response

This method can also be used in the global `responded`. For example, in most cases, the request api will return json data, but there may be a file download interface, which will return a binary data stream. In this case Next, you can use different metadata in `responded` to handle different responses separately.

**Step 1: When creating a method instance, you also need to assign a metadata**

```javascript
const downloadAPI = filePath => {
  const methodInstance = alovaInst.Post('/download_file', {
    filePath
  });
  methodInstance.meta = {
    isDownload: true
  };
  return methodInstance;
};
```

**Step 2: Use metadata as the basis for judgment in `responded`**

```javascript
createAlova({
   //...
   responded:
     onSuccess: (response, method) => method.meta?.isDownload ? response.blob() : response.json()
     onError: (error, method) => {
       // You can also access the metadata of the method instance when responding to errors
     }
   }
});
```

## Use metadata to pass data

In some cases, if you want to add additional information to different method instances for use elsewhere, you can also use metadata to save it. Take the uniform generation of different method instance ids as an example.

```javascript
createAlova({
  beforeRequest(method) {
    if (!method.meta.generateId) {
      method.meta.uid = generateUUID();
    }
  },

  responded: {
    onSuccess(response, method) {
      // Access the meta data generated by the current method in a successful request
      const currentMethodUID = method.meta.uid;
    },
    onError(error, method) {
      // Access the meta data generated by the current method in the request failure
      const currentMethodUID = method.meta.uid;
    }
  }
});
```

## Prompt for non-typescript projects

In a non-typescript environment, you can use any attribute as an information carrier, not limited to the `meta` attribute.

```javascript
methodInstance.showResponseMsg = true;
methodInstance.others = 'abc';
```

It’s just that in the typescript environment, any property name will report `the property “$0” does not exist. ts(2339)`, so in the type we specify the `meta` attribute as the information carrier.
