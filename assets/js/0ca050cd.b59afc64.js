"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8925],{84037:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=t(85893),s=t(11151);t(22778),t(24243),t(20718);const r={title:"Cache Mode"},i=void 0,o={id:"tutorial/cache/mode",title:"Cache Mode",description:"Cache mode can be set at different granularities, such as global or request level. When set globally, all method instances created by the same alova instance will inherit the setting.",source:"@site/docs/tutorial/05-cache/01-mode.md",sourceDirName:"tutorial/05-cache",slug:"/tutorial/cache/mode",permalink:"/tutorial/cache/mode",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/05-cache/01-mode.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cache Mode"},sidebar:"tutorial",previous:{title:"Response Cache Details",permalink:"/tutorial/cache/"},next:{title:"Auto Invalidate",permalink:"/tutorial/cache/auto-invalidate"}},c={},l=[{value:"Memory Mode (Default)",id:"memory-mode-default",level:2},{value:"Client",id:"client",level:3},{value:"Server",id:"server",level:3},{value:"Restore mode",id:"restore-mode",level:2},{value:"Client",id:"client-1",level:3},{value:"What to do if data changes?",id:"what-to-do-if-data-changes",level:4},{value:"Server",id:"server-1",level:3},{value:"Set alova id",id:"set-alova-id",level:2},{value:"Set cache mode globally",id:"set-cache-mode-globally",level:2},{value:"Globally turn off cache mode",id:"globally-turn-off-cache-mode",level:2},{value:"Set different expiration times",id:"set-different-expiration-times",level:2},{value:"Expiration time type",id:"expiration-time-type",level:2},{value:"Relative time",id:"relative-time",level:3},{value:"Absolute time",id:"absolute-time",level:3},{value:"Automatic response maintenance instructions",id:"automatic-response-maintenance-instructions",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Cache mode can be set at different granularities, such as global or request level. When set globally, all method instances created by the same alova instance will inherit the setting."}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"info",children:(0,a.jsx)(n.p,{children:"Whether to use cache mode and which cache mode to use depends on the scenario. The following will mention their usage scenarios when introducing different cache modes separately."})}),"\n",(0,a.jsx)(n.h2,{id:"memory-mode-default",children:"Memory Mode (Default)"}),"\n",(0,a.jsx)(n.p,{children:"Memory mode belongs to the single-level cache (L1 cache) mode. By default, the cache is placed in memory. It is the most commonly used cache mode."}),"\n",(0,a.jsx)(n.mermaid,{value:"flowchart LR\n  A[User request] --\x3e B{Check L1 cache}\n  B --\x3e|Hit| C[Return data]\n  B --\x3e|Miss| F[Request API interface]\n  F --\x3e G[Update L1 cache]\n  G --\x3e C\n  C --\x3e H[End]\n\n  style F stroke-width:8px"}),"\n",(0,a.jsx)(n.p,{children:"By default, GET request has a memory cache time of 300000ms (5 minutes). Developers can also customize the cache setting. Please continue reading."}),"\n",(0,a.jsx)(n.h3,{id:"client",children:"Client"}),"\n",(0,a.jsx)(n.p,{children:"In the client, refreshing the page cache will invalidate it. The memory mode is generally used to solve the performance consumption caused by frequent requests for the same data in a short period of time (several minutes or seconds). For example, when you are writing a todo detail page, you may think that users will frequently click to view details in the todo list. If the user repeatedly views a certain detail, the interface will no longer be requested repeatedly, and the data can be returned immediately, which improves the response speed and reduces the server pressure. At this time, we can set the response data cache for a todo detail method instance."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"alovaInstance.GET('/todo/list', {\n  // ...\n  // highlight-start\n  cacheFor: {\n    // Set the cache mode to memory mode\n    mode: 'memory',\n\n    // Unit is milliseconds\n    // When set to `Infinity`, it means that the data will never expire. When set to 0 or a negative number, it means that it will not be cached\n    expire: 60 * 10 * 1000\n  }\n  // highlight-end\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Memory mode is the default mode. You can shorten it like this"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"alovaInstance.GET('/todo/list', {\n  // ...\n  // highlight-start\n  cacheFor: 60 * 10 * 1000\n  // highlight-end\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"server",children:"Server"}),"\n",(0,a.jsx)(n.p,{children:"In the service, it is usually used in scenarios where the interface requires high access frequency and low latency to reduce the pressure on the downstream server. The usage method is the same as the client."}),"\n",(0,a.jsx)(n.p,{children:"Note when using it on the server:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Too much cache will always consume server memory. You can use ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/lru-cache",children:"lru-cache"})," to control memory consumption."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["If you need to share cache in a single-machine nodejs cluster environment, you can use ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/@alova/psc",children:"@alova/psc"})," to create a cache solution for shared memory between processes."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { createPSCAdapter, NodeSyncAdapter } = require('@alova/psc');\nconst { LRUCache } = require('lru-cache');\n\nfunction lRUCache(options = {}) {\n  const cache = new LRUCache(options);\n  return {\n    set(key, value) {\n      return cache.set(key, value);\n    },\n\n    get(key) {\n      return cache.get(key);\n    },\n\n    remove(key) {\n      return cache.delete(key);\n    },\n\n    clear() {\n      return cache.clear();\n    }\n  };\n}\n\nconst alovaInstance = createAlova({\n  baseURL: 'https://api.alovajs.dev',\n\n  // Inter-process shared cache adapter\n  l1Cache: createPSCAdapter(\n    NodeSyncAdapter(),\n    lRUCache({\n      max: 1000,\n      ttl: 1000 * 60 * 10\n    })\n  )\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Memory cache mode corresponds to l1 cache. Here we replace the cache adapter with lru-cache shared between processes. You can also ",(0,a.jsx)(n.a,{href:"/tutorial/advanced/custom/storage-adapter",children:"customize the storage adapter"}),". For example, when you only need a single-level cache, you can also directly set the l1 cache to the redis adapter."]}),"\n",(0,a.jsx)(n.h2,{id:"restore-mode",children:"Restore mode"}),"\n",(0,a.jsx)(n.p,{children:"Restore mode corresponds to multi-level cache, namely L1 and L2 cache. After the restore mode is turned on, the response data will be stored in both L1 and L2 caches. When the L1 cache fails, the data will be read from the L2 cache and then the L1 cache will be updated. The interface will be requested again when the L2 cache also fails."}),"\n",(0,a.jsx)(n.mermaid,{value:"flowchart LR\n  A[User request] --\x3e B{Check L1 cache}\n  B --\x3e|Hit| C[Return data]\n  B --\x3e|Miss| D{Check L2 cache}\n  D --\x3e|Hit| E[Update L1 cache]\n  E --\x3e C\n  D --\x3e|Miss| F[Request API interface]\n  F --\x3e G[Update L2 cache]\n  G --\x3e E\n  C --\x3e H[End]\n\n  style F stroke-width:8px"}),"\n",(0,a.jsx)(n.h3,{id:"client-1",children:"Client"}),"\n",(0,a.jsx)(n.p,{children:"In the client, when the cache has not expired, it will not be invalidated even if the page cache is refreshed. It is generally used for some data that requires server-side management but is basically unchanged, such as the specific dates of holidays each year are different, but will not change again. In this scenario, we only need to set the cache expiration time to the last minute of this year."}),"\n",(0,a.jsxs)(n.p,{children:["When using alova in the client, ",(0,a.jsx)(n.code,{children:"localStorage"})," is used as the L2 storage adapter by default. You can also ",(0,a.jsx)(n.a,{href:"/tutorial/advanced/custom/storage-adapter",children:"customize the storage adapter"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Set on the method instance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const todoListGetter = alovaInstance.Get('/todo/list', {\n  // ...\n  // highlight-start\n  cacheFor: {\n    // Set cache mode to persistence mode\n    mode: 'restore',\n    // Cache time\n    expire: 60 * 10 * 1000\n  }\n  // highlight-end\n});\n"})}),"\n",(0,a.jsx)(n.h4,{id:"what-to-do-if-data-changes",children:"What to do if data changes?"}),"\n",(0,a.jsxs)(n.p,{children:["When the method instance is set to restore mode, it may be necessary to allow users to re-cache the changed data after publishing the application due to changes in interface data or changes in the logic of front-end processing response data. At this time, you can set the cache tag through the ",(0,a.jsx)(n.code,{children:"tag"})," attribute. Each piece of persistent data contains a ",(0,a.jsx)(n.code,{children:"tag"})," identifier. When the ",(0,a.jsx)(n.code,{children:"tag"})," changes, the original persistent data will become invalid, and new data will be obtained again and identified with a new ",(0,a.jsx)(n.code,{children:"tag"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const todoListGetter = alovaInstance.Get('/todo/list', {\n  // ...\n  cacheFor: {\n    mode: 'restore',\n    expire: 60 * 10 * 1000,\n\n    // highlight-start\n    // Add or modify tag parameters, cached data will become invalid\n    // It is recommended to use version number management\n    tag: 'v1'\n    // highlight-end\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"server-1",children:"Server"}),"\n",(0,a.jsx)(n.p,{children:"Generally used for multi-level cache, using L1 as memory cache and L2 as persistent cache, such as redis and memcached."}),"\n",(0,a.jsx)(n.p,{children:"Some application scenarios are as follows:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"High access frequency and low latency requirements: such as hot news and product details, which can further reduce network overhead and maintain faster response when the network is unstable."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Reduce the pressure on downstream servers, such as services with peak access periods, and the upper-level cache can effectively reduce the pressure on the backend database and microservices."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Integrate data merging and processing of multiple downstream servers. Multiple serial requests may lead to longer response time, and may also consume performance due to complex data conversion. The converted data can be cached."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"API rate limit and billing, weather forecast service API updates weather information once an hour, geographic location data API, etc."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["When using alova on the server, there is no L2 storage adapter by default. The implementation of file storage adapter and redis adapter are provided in ",(0,a.jsx)(n.a,{href:"/tutorial/project/best-practice/l2-storage",children:"Server-side L2 storage practice"}),". You can also ",(0,a.jsx)(n.a,{href:"/tutorial/advanced/custom/storage-adapter",children:"customize storage adapter"}),", for example, use MongoDB, MySQL and other databases as storage adapters for response data."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"warning",children:(0,a.jsxs)(n.p,{children:["When the request body is special data such as ",(0,a.jsx)(n.strong,{children:"FormData"}),", ",(0,a.jsx)(n.strong,{children:"Blob"}),", ",(0,a.jsx)(n.strong,{children:"ArrayBuffer"}),", ",(0,a.jsx)(n.strong,{children:"URLSearchParams"}),", ",(0,a.jsx)(n.strong,{children:"ReadableStream"}),", it will be considered that you have the intention to communicate with the server, and no caching will be performed in this case."]})}),"\n",(0,a.jsx)(n.h2,{id:"set-alova-id",children:"Set alova id"}),"\n",(0,a.jsx)(n.p,{children:"Each cache key contains the namespace of the alova instance, in the following format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"cacheKey = [prefix][alova-id][method-json-string]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["By default, [alova-id] increments in the order in which alova is created. When using persistent cache in a server environment, it is strongly recommended to set the namespace of the alova id fixed cache key. ",(0,a.jsx)(n.strong,{children:"This is particularly important"}),", otherwise the order in which multiple alova instances are created may change, resulting in the inability to match the corresponding cache."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const userAlova = createAlova({\n  // ...\n  id: 'user'\n});\n\nconst orderAlova = createAlova({\n  // ...\n  id: 'order'\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"set-cache-mode-globally",children:"Set cache mode globally"}),"\n",(0,a.jsx)(n.p,{children:"If you need to set the cache mode globally, you can do it as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const alovaInstance = createAlova({\n  // ...\n  // highlight-start\n  cacheFor: {\n    // Set the cache mode for POST uniformly\n    POST: {\n      mode: 'restore',\n      expire: 60 * 10 * 1000\n    },\n    // Set the cache mode for HEAD requests uniformly\n    HEAD: 60 * 10 * 1000\n  }\n  // highlight-end\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["After this, method instances created through the ",(0,a.jsx)(n.code,{children:"alovaInstance"})," instance will use this cache setting by default, and you can also override it in the method instance."]}),"\n",(0,a.jsx)(n.h2,{id:"globally-turn-off-cache-mode",children:"Globally turn off cache mode"}),"\n",(0,a.jsx)(n.p,{children:"If you don't want to use anyIf you want to use any request cache, you can turn it off globally. If you want to use it only for a few specific requests, you can also turn it off globally and set it in the specified method instance."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const alovaInstance = createAlova({\n  // ...\n  // highlight-start\n  // Set to null to globally turn off all request caches\n  cacheFor: null\n  // highlight-end\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"set-different-expiration-times",children:"Set different expiration times"}),"\n",(0,a.jsxs)(n.p,{children:["In restore mode, you can also set different expiration times for L1 and L2 caches. Set ",(0,a.jsx)(n.code,{children:"expire"})," to a function, which will be called when setting L1 and L2 caches respectively."]}),"\n",(0,a.jsx)(n.p,{children:"The following is an example of setting different expiration times for a single request."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"alovaInst.Get('/user/profile', {\n  // ...\n  cacheFor: {\n    mode: 'restore',\n    expire: ({ method, mode }) => {\n      // Set 5 minutes cache in l1 cache and 1 day cache in l2 cache\n      return mode === 'memory' ? 5 * 60 : 24 * 60 * 60;\n    }\n  }\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The following is an example of setting different expiration times for GET requests globally, when the method metadata has the ",(0,a.jsx)(n.code,{children:"setDiffExpire"})," flag."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const alovaInst = createAlova({\n  // ...\n  cacheFor: {\n    GET: {\n      mode: 'restore',\n      expire: ({ method, mode }) => {\n        if (method.meta.setDiffExpire) {\n          // Set 5 minutes cache in l1 cache and 1 day cache in l2 cache\n          return mode === 'memory' ? 5 * 60 : 24 * 60 * 60;\n        }\n        return 5 * 60;\n      }\n    }\n  }\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"expiration-time-type",children:"Expiration time type"}),"\n",(0,a.jsxs)(n.p,{children:["There are two types of expiration time to choose from, namely ",(0,a.jsx)(n.strong,{children:"relative time"})," and ",(0,a.jsx)(n.strong,{children:"absolute time"})]}),"\n",(0,a.jsx)(n.h3,{id:"relative-time",children:"Relative time"}),"\n",(0,a.jsxs)(n.p,{children:["That is, the expiration time starts when the cache data is saved, in ",(0,a.jsx)(n.strong,{children:"milliseconds"}),". The above examples are all of this type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cacheFor: 60 * 10 * 1000;\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cacheFor: {\n  expire: 60 * 10 * 1000,\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"absolute-time",children:"Absolute time"}),"\n",(0,a.jsx)(n.p,{children:"With a specific time point as the expiration time, the cache will expire at the set time point"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cacheFor: new Date('2030-01-01');\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"cacheFor: {\n  expire: new Date('2030-01-01');\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"automatic-response-maintenance-instructions",children:"Automatic response maintenance instructions"}),"\n",(0,a.jsxs)(n.p,{children:["The key of the response data cache is a combination of the request method (method), request address (url), request header parameters (headers), url parameters (params), and request body parameters (requestBody) of the method instance as a unique identifier. Any information or location will be treated as a different key. If you want to customize the cache key, you can refer to ",(0,a.jsx)(n.a,{href:"/tutorial/advanced/in-depth/custom-method-key",children:"Custom method key"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Note that the key of the response data cache (or method) is ",(0,a.jsx)(n.strong,{children:"only"})," determined when the method created. After the method instance is created, modifying any of the following: request method (method), request address (url), request header parameters (headers), url parameters (params), or request body parameters (requestBody) will not cause the key to change, which will result in the cache pointing to the same value."]}),"\n",(0,a.jsx)(n.p,{children:"In this case, if you need to cache separately pointing to different values, consider dynamically creating methods."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const alovaInst = createAlova({\n  // ...\n  beforeRequest(method) {\n    const sec = Math.floor(Date.now() / 1000);\n    method.config.headers.sec = sec;\n  }\n});\n\nconst Getter = () =>\n  alovaInst.Get('/user/profile', {\n    // ...\n    cacheFor: 10 * 1000\n  });\n\n// create a new method\nGetter().send();\n// or\nuseRequest(Getter);\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},22778:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(93894),s=(t(67294),t(85893));const r=()=>(0,s.jsx)(a.Z,{src:"https://codesandbox.io/p/sandbox/github/alovajs/alova-examples/tree/main/packages/memory-cache?embed=1&file=%2Fsrc%2FApp.vue"})},24243:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(93894),s=(t(67294),t(85893));const r=()=>(0,s.jsx)(a.Z,{src:"https://codesandbox.io/p/sandbox/github/alovajs/alova-examples/tree/main/packages/storage-placeholder?embed=1&file=%2Fsrc%2FApp.vue"})},20718:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(93894),s=(t(67294),t(85893));const r=()=>(0,s.jsx)(a.Z,{src:"https://codesandbox.io/p/sandbox/github/alovajs/alova-examples/tree/main/packages/storage-restore?embed=1&file=%2Fsrc%2FApp.vue"})},93894:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(33692),s=t(95999),r=t(85893);const i=e=>{let{src:n}=e;return(0,r.jsxs)("div",{children:[(0,r.jsx)("iframe",{src:n,style:{width:"100%",height:"1000px",border:"0",borderRadius:"4px",overflow:"hidden"},allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,r.jsx)(a.Z,{to:n,children:(0,r.jsx)(s.Z,{id:"example.open in new tab",children:"Encounter troubles? Click to open this in new page."})})]})}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>i});var a=t(67294);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);