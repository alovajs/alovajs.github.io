"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[3702],{95994:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var t=a(85893),o=a(11151);const s={title:"alova v3.0 Release Notes"},r=void 0,c={id:"release-notes-v3",title:"alova v3.0 Release Notes",description:"Overall upgrade goal",source:"@site/docs/release-notes-v3.md",sourceDirName:".",slug:"/release-notes-v3",permalink:"/release-notes-v3",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/release-notes-v3.md",tags:[],version:"current",frontMatter:{title:"alova v3.0 Release Notes"}},i={},d=[{value:"Overall upgrade goal",id:"overall-upgrade-goal",level:2},{value:"Redesign alova",id:"redesign-alova",level:2},{value:"Redesign the structure",id:"redesign-the-structure",level:3},{value:"Redesign cache mode",id:"redesign-cache-mode",level:3},{value:"1. Remove the placeholder mode",id:"1-remove-the-placeholder-mode",level:4},{value:"2. Memory cache and store cache support asynchronous operations",id:"2-memory-cache-and-store-cache-support-asynchronous-operations",level:4},{value:"3. Cache operation function optimization",id:"3-cache-operation-function-optimization",level:4},{value:"4. Set different cache expiration times",id:"4-set-different-cache-expiration-times",level:4},{value:"method snapshot matcher modification",id:"method-snapshot-matcher-modification",level:3},{value:"Rewrite snapshot matching and automatic invalidation cache algorithm",id:"rewrite-snapshot-matching-and-automatic-invalidation-cache-algorithm",level:3},{value:"Deprecated items",id:"deprecated-items",level:2},{value:"Deprecated useWatcher&#39;s sendable",id:"deprecated-usewatchers-sendable",level:3},{value:"Deprecate <code>enableDownload/enableUpload</code> of method",id:"deprecate-enabledownloadenableupload-of-method",level:3},{value:"Deprecate <code>placeholder</code> mode of method",id:"deprecate-placeholder-mode-of-method",level:3},{value:"Remove deprecated responsed",id:"remove-deprecated-responsed",level:3},{value:"Deprecated error log control parameter errorLogger",id:"deprecated-error-log-control-parameter-errorlogger",level:3},{value:"Deprecated <code>onMatch</code> hook of <code>updateState</code>",id:"deprecated-onmatch-hook-of-updatestate",level:3},{value:"Deprecated <code>matchSnapshotMethod</code>",id:"deprecated-matchsnapshotmethod",level:3},{value:"Deprecated <code>getMethodKey</code>",id:"deprecated-getmethodkey",level:3},{value:"Deprecated middleware items",id:"deprecated-middleware-items",level:3},{value:"@alova/vue-options deprecates <code>mapWatcher</code>",id:"alovavue-options-deprecates-mapwatcher",level:3},{value:"@alova/scene-* optimization",id:"alovascene--optimization",level:2},{value:"usePagination",id:"usepagination",level:3},{value:"1. Set abortLast to true by default",id:"1-set-abortlast-to-true-by-default",level:4},{value:"Optimize the use under react",id:"optimize-the-use-under-react",level:4},{value:"useForm",id:"useform",level:3},{value:"1. No longer supports directly passing in id to return cached hookReturns",id:"1-no-longer-supports-directly-passing-in-id-to-return-cached-hookreturns",level:4},{value:"useSQRequest",id:"usesqrequest",level:3},{value:"1. <code>updateStateEffect</code> no longer supports the use of method matchers",id:"1-updatestateeffect-no-longer-supports-the-use-of-method-matchers",level:4},{value:"2. Modification of <code>SilentMethod</code> member method usage",id:"2-modification-of-silentmethod-member-method-usage",level:4},{value:"accessAction",id:"accessaction",level:3},{value:"All useHook&#39;s force function is changed to AlovaEvent object",id:"all-usehooks-force-function-is-changed-to-alovaevent-object",level:3},{value:"Field name modification",id:"field-name-modification",level:2},{value:"<code>method.__key__</code> is simplified to <code>method.key</code>",id:"method__key__-is-simplified-to-methodkey",level:3},{value:"<code>method.transformData</code> is simplified to <code>method.transform</code>",id:"methodtransformdata-is-simplified-to-methodtransform",level:3},{value:"<code>method.localCache</code> changed to <code>method.cacheFor</code>",id:"methodlocalcache-changed-to-methodcachefor",level:3},{value:"All <code>sendArgs</code> are changed to <code>args</code>",id:"all-sendargs-are-changed-to-args",level:3},{value:"@alova/adapter-uniapp export name change",id:"alovaadapter-uniapp-export-name-change",level:3},{value:"Other optimizations",id:"other-optimizations",level:2},{value:"Support dependency collection",id:"support-dependency-collection",level:3},{value:"middleware optimization",id:"middleware-optimization",level:3},{value:"All event binding functions return their own objects",id:"all-event-binding-functions-return-their-own-objects",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"overall-upgrade-goal",children:"Overall upgrade goal"}),"\n",(0,t.jsx)(n.p,{children:'alova@3.0 aims to further achieve the goal of "Run in any JS environment" and make it easier to use. We have fully redesigned and refactored the code in 3.0 to make it more user-friendly on the server and in more JS environments.'}),"\n",(0,t.jsx)(n.h2,{id:"redesign-alova",children:"Redesign alova"}),"\n",(0,t.jsx)(n.h3,{id:"redesign-the-structure",children:"Redesign the structure"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Change the fetch adapter export path to ",(0,t.jsx)(n.code,{children:"alova/fetch/"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const adapterFetch = require('alova/fetch');\nconst alova = createAlova({\n  requestAdapter: adapterFetch()\n});\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"JS package structure adjustment"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Merge the original ",(0,t.jsx)(n.code,{children:"@alova/scene-vue"}),", ",(0,t.jsx)(n.code,{children:"@alova/scene-react"}),", ",(0,t.jsx)(n.code,{children:"@alova/scene-svelte"})," into a package ",(0,t.jsx)(n.code,{children:"alova/client"})," using cross-UI framework technology."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Move ",(0,t.jsx)(n.code,{children:"useRequest/useWatcher/useFetcher"})," to ",(0,t.jsx)(n.code,{children:"alova/client"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Add ",(0,t.jsx)(n.code,{children:"alova/server"})," to export the server-side scene strategy module."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Now you can directly use ",(0,t.jsx)(n.code,{children:"alova/client"})," and ",(0,t.jsx)(n.code,{children:"alova/server"})," as long as you install ",(0,t.jsx)(n.code,{children:"alova"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import vueHook from 'alova/vue';\nimport reactHook from 'alova/react';\nimport svelteHook from 'alova/svelte';\nimport vueDemiHook from 'alova/vue-demi';\nimport { useRequest, useWatcher, usePagination } from 'alova/client';\nimport adapterFetch from 'alova/fetch';\n\nconst alova = createAlova({\n  statesHook: vueHook,\n  requestAdapter: adapterFetch()\n});\nconst { data, loading, error } = useRequest(alova.Get('/api/user'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"server hooks usage example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { useRateLimit, sendCaptcha } = require('alova/server');\nimport adapterFetch from 'alova/fetch';\nconst alova = createAlova({\n  requestAdapter: adapterFetch()\n});\nconst requestCaptcha = mobile => alova.Get('/api/captcha', { params: { mobile } });\ntry {\n  await sendCaptcha(requestCaptcha, { key: mobile, countdown: 60 });\n} catch (error) {\n  throw new Error('Send failed');\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"redesign-cache-mode",children:"Redesign cache mode"}),"\n",(0,t.jsx)(n.p,{children:"In order to make alova shine on the server side and simplify alova's API, we considered the following cache application scenarios\nApplication scenarios"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"High access frequency and low latency requirements, such as hot news and product details, can further reduce network overhead and maintain faster response when the network is unstable."}),"\n",(0,t.jsx)(n.li,{children:"Reduce the pressure on downstream servers. For example, for services with peak access periods, the upper-level cache can effectively reduce the pressure on the backend database and microservices."}),"\n",(0,t.jsx)(n.li,{children:"Integrate data merging and processing of multiple downstream servers. Multiple serial requests may lead to longer response time and may consume performance due to complex data conversion. The converted data can be cached."}),"\n",(0,t.jsx)(n.li,{children:"API rate limit and billing. Weather forecast service API updates weather information every hour, geographic location data API, etc."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"As well as most asynchronous cache processing mechanisms, the following redesigns have been made:"}),"\n",(0,t.jsx)(n.h4,{id:"1-remove-the-placeholder-mode",children:"1. Remove the placeholder mode"}),"\n",(0,t.jsx)(n.p,{children:"Placeholder is only valid on the client and with useHook. In 3.0, initialData is added to support functions to achieve the same effect, as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { onSuccess } = useRequest(Getter, {\n  initialData() {\n    // Set the last response data\n    const storedData = localStorage.getItem('placeholder-data');\n    return JSON.parse(storedData || '{}');\n\n    // Also use alova's storage adapter\n    // return alovaInst.l2cache.get('placeholder-data');\n  }\n});\nonSuccess(({ data, method }) => {\n  // Save response data\n  localStorage.setItem('placeholder-data', JSON.stringify(data));\n\n  // Also use alova's storage adapter\n  alovaInst.l2cache.set('placeholder-data', data);\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"At this point, there are only two cache modes, the definition and usage remain unchanged, but the memory mode supports custom adapters and asynchronous operations, as follows:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"memory mode"}),": supports custom memory adapters and asynchronous operations, for example, it can be customized as LRUCache in the server scenario, and can also manage processes across processes, or manage caches anywhere else you want."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"restore mode"}),": response data will be cached in both memory and storage. When requesting, the memory cache will be searched first. If not found, it will be searched in storage. After a hit, the cache will be restored to the memory cache. If both miss, a request will be initiated."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-memory-cache-and-store-cache-support-asynchronous-operations",children:"2. Memory cache and store cache support asynchronous operations"}),"\n",(0,t.jsx)(n.p,{children:"We can use memory as the first-level cache and storage cache as the second-level cache."}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Note: In terms of the use of a single cache, there is no difference between memory mode and storage mode. Both support custom adapters and asynchronous operations. You can also customize the cache to be placed anywhere, but the implementation mechanism is that the first-level cache takes precedence over the second-level cache. In restore mode, you can implement the mechanism of the second-level cache restoring the first-level cache."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Scenario recommendation: Memory mode uses local memory (including cross-process sharing in the cluster), and storage mode is placed in a persistent cache such as a file or Redis."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const { LRUCache } = require('lru-cache');\nconst { createClient } = require('redis');\n\nconst client = createClient(/*...*/);\nconst alovaInst = createAlova({\n  // ...\n  // l1 is the highest priority cache, that is, the original memory cache\n  l1Cache: new LRUCache(),\n  // l2 is a lower memory cache, that is, the original persistent cache\n  l2Cache: {\n    set: async (key, [data, expireTs]) => {\n      await client.set(key, data, {\n        EX: Number((expireTs - Date.now()) / 1000)\n      });\n    },\n    get: async key => client.get(key),\n    remove: async key => client.set(key, '', 0)\n  }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"An example of handling cache avalanche, solved by adding random expiration time"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"alova.Get('/xxx', {\n  cacheFor: {\n    expire: 100000 * Math.floor(Math.random() * 1000),\n    mode: 'restore'\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"3-cache-operation-function-optimization",children:"3. Cache operation function optimization"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["In order to adapt to asynchronous storage adapters, cache operation functions ",(0,t.jsx)(n.code,{children:"setCache"}),", ",(0,t.jsx)(n.code,{children:"queryCache"}),", ",(0,t.jsx)(n.code,{children:"invalidateCache"})," are changed to asynchronous functions."]}),"\n",(0,t.jsx)(n.li,{children:"Add separate control for level 1 and level 2 cache."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"setCache/queryCache/invalidateCache"})," no longer supports method matcher parameters. For details, see the method snapshot matcher modification section below."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"await setCache(methodInstance, data, {\n  /**\n   * Cache policy.\n   * - l1: only set l1 cache.\n   * - l2: only set l2 cache.\n   * - all: set l1 cache and set l2 cache (method cache mode needs to be \"restore\").\n   * @default all\n   */\n  policy: 'all'\n});\n\n/**\n * Cache policy.\n * - l1: only query l1 cache.\n * - l2: only query l2 cache.\n * - all: query l1 cache first, and query l2 cache if l1 cache is not found (method cache mode needs to be \"restore\").\n * @default all\n */\nawait queryCache(methodInstance, {\n  policy: 'all'\n});\nawait invalidateCache([methodInstance1, methodInstance2 /*...*/]);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"4-set-different-cache-expiration-times",children:"4. Set different cache expiration times"}),"\n",(0,t.jsx)(n.p,{children:"In high access frequency and low latency requirements, we often need to cache high-frequency access data in the local server for a short time, and set a cache with a longer expiration time in the remote cache server. At this time, we can do this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// Global settings\nconst alovaInst = createAlova({\n  // ...\n  cacheFor: {\n    GET: {\n      mode: 'restore',\n      expire: ({ method, mode }) => {\n        if (method.meta.setDiffExpire) {\n          // Set a 5-minute cache in l1 cache and a 1-day cache in l2 cache\n          return mode === 'memory' ? 5 * 60 : 24 * 60 * 60;\n        }\n      }\n    }\n  }\n});\n\n// Set for a single request\nalovaInst.Get('/user/profile', {\n  // ...\n  cacheFor: {\n    mode: 'restore',\n    expire: ({ method, mode }) => {\n      // Set 5 minutes cache in l1 cache, 1 day cache in l2 cache\n      return mode === 'memory' ? 5 * 60 : 24 * 60 * 60;\n    }\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"method-snapshot-matcher-modification",children:"method snapshot matcher modification"}),"\n",(0,t.jsxs)(n.p,{children:["The original method matcher can be used in ",(0,t.jsx)(n.code,{children:"setCache"}),", ",(0,t.jsx)(n.code,{children:"queryCache"}),", ",(0,t.jsx)(n.code,{children:"invalidateCache"}),"ache",(0,t.jsx)(n.code,{children:", "}),"useFetcher.fetch",(0,t.jsx)(n.code,{children:", "}),"updateState",(0,t.jsx)(n.code,{children:", but the number of method instances they require is different. In addition, there is an ambiguity problem. Only method instances that have been requested are saved in the matcher container (memory). However, when the page is refreshed, when the persistent cache is obtained or invalidated, for example, "}),"queryCache('method-name')",(0,t.jsx)(n.code,{children:"or"}),"invalidateCache('method-name')` may be invalid because the method instance cannot be found in the snapshot, causing ambiguity."]}),"\n",(0,t.jsx)(n.p,{children:"Therefore, in alova@3, the method matcher is externalized, and the above five functions are changed to only support the passing of method instances. Users can clearly know whether the method instance snapshot has been found, which is more unified in usage and does not cause ambiguity. The code design is as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// alova@2 writing\ninvalidateCache('method-name');\nconst data = queryCache('method-name2');\n\n// alova@3 writing\nconst methodSnapshots = alovaInst.snapshots.match('method-name'); // Match multiple\ninvalidateCache(methodSnapshots);\nconst oneSnapshot = alovaInst.snapshots.match('method-name2', true); // Match only one\nconst data = await queryCache(oneSnapshot);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rewrite-snapshot-matching-and-automatic-invalidation-cache-algorithm",children:"Rewrite snapshot matching and automatic invalidation cache algorithm"}),"\n",(0,t.jsx)(n.p,{children:"In 2.x, snapshot matching and automatic invalidation cache algorithms both search for the target method by traversing method snapshots. On the server side or long-running clients, the matching efficiency may be reduced due to too many snapshots, which will cause performance loss. In 3.x, the search steps will be reduced to improve the search efficiency.\nExport new function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"declare function hitCacheBySource(sourceMethod: Method): Promise<void>;\nawait hitCacheBySource(alova.Get('/api/profile'));\n"})}),"\n",(0,t.jsx)(n.h2,{id:"deprecated-items",children:"Deprecated items"}),"\n",(0,t.jsx)(n.h3,{id:"deprecated-usewatchers-sendable",children:"Deprecated useWatcher's sendable"}),"\n",(0,t.jsx)(n.p,{children:"Deprecated useWatcher's sendable, judged by middleware."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// alova@2.x\nlet sendable = false;\nuseWatcher(() => method, [xxx], { sendable: () => sendable });\n\n// alova@3.x\nlet sendable = false;\nuseWatcher(() => method, [xxx], {\n  async middleware(_, next) {\n    if (sendable) {\n      return next();\n    }\n  }\n});\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"deprecate-enabledownloadenableupload-of-method",children:["Deprecate ",(0,t.jsx)(n.code,{children:"enableDownload/enableUpload"})," of method"]}),"\n",(0,t.jsx)(n.p,{children:"These two parameters are no longer needed in method. They will be changed to automatically determine whether to enable or not. Getter will be used to determine whether uploading and downloading are used externally."}),"\n",(0,t.jsxs)(n.h3,{id:"deprecate-placeholder-mode-of-method",children:["Deprecate ",(0,t.jsx)(n.code,{children:"placeholder"})," mode of method"]}),"\n",(0,t.jsxs)(n.p,{children:['We have mentioned in "redesign cache mode", ',(0,t.jsx)(n.code,{children:"placeholder"})," mode has been replaced by other ways."]}),"\n",(0,t.jsx)(n.h3,{id:"remove-deprecated-responsed",children:"Remove deprecated responsed"}),"\n",(0,t.jsxs)(n.p,{children:["It is recommended to use the ",(0,t.jsx)(n.code,{children:"responded"})," field uniformly in createAlova."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"createAlova({\n  responded() {\n    // ...\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deprecated-error-log-control-parameter-errorlogger",children:"Deprecated error log control parameter errorLogger"}),"\n",(0,t.jsx)(n.p,{children:"In 2.x, an error message will be printed in the console whenever there is a request error. When the error is not caught at the request, the console will display two identical error messages, which is not very friendly."}),"\n",(0,t.jsx)(n.p,{children:"In 3.x, if onError is bound or error is used, no error will be thrown. Otherwise, an error will be thrown to avoid displaying two error messages."}),"\n",(0,t.jsxs)(n.h3,{id:"deprecated-onmatch-hook-of-updatestate",children:["Deprecated ",(0,t.jsx)(n.code,{children:"onMatch"})," hook of ",(0,t.jsx)(n.code,{children:"updateState"})]}),"\n",(0,t.jsxs)(n.p,{children:["Because updateState no longer supports method matchers, the ",(0,t.jsx)(n.code,{children:"onMatch"})," hook is no longer useful."]}),"\n",(0,t.jsxs)(n.h3,{id:"deprecated-matchsnapshotmethod",children:["Deprecated ",(0,t.jsx)(n.code,{children:"matchSnapshotMethod"})]}),"\n",(0,t.jsxs)(n.p,{children:["In alova@3.0, ",(0,t.jsx)(n.code,{children:"alova.snapshots.match"})," is used to obtain the instance snapshot under the corresponding alova."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"alova.snapshots.match('method-name');\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"deprecated-getmethodkey",children:["Deprecated ",(0,t.jsx)(n.code,{children:"getMethodKey"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"mailto:alova@3.x",children:"alova@3.x"})," no longer exports ",(0,t.jsx)(n.code,{children:"getMethodKey"}),", you can import the function that calculates the method key from the following methods."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { key } from '@alova/shared/function';\n\nconst methodKey = key(methodInstance);\n\n// or\nconst currentKey = methodInstance.generateKey();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deprecated-middleware-items",children:"Deprecated middleware items"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Deprecated ",(0,t.jsx)(n.code,{children:"context.update"})," function."]}),"\n",(0,t.jsxs)(n.li,{children:["Deprecate event decorations such as ",(0,t.jsx)(n.code,{children:"decorateSuccess/decorateError/decorateComplete"}),". Now you can decorate events like this:"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { decorateEvent } from '@alova/shared/createEventManager';\n\nconst exposure = useRequest(/* ... */);\nexposure.onSuccess = decorateEvent(exposure.onSuccess, (handler, event) => {\n  event.extraAttribute = {\n    /* ... */\n  }; // Mount extra attributes for event\n  const res = handler(event, 1, 2, 3); // Pass extra parameters to event callback and get return value\n  // ...\n});\n\nexposure.onSuccess((event, extra1, extra2, extra3) => {\n  event.extraAttribute; // Extra attributes\n  extra1; // 1\n  extra2; // 2\n  extra3; // 3\n  return 100;\n});\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"alovavue-options-deprecates-mapwatcher",children:["@alova/vue-options deprecates ",(0,t.jsx)(n.code,{children:"mapWatcher"})]}),"\n",(0,t.jsxs)(n.p,{children:["Listening to the return status of useHook no longer requires the use of the auxiliary function ",(0,t.jsx)(n.code,{children:"mapWatcher"}),", so it is deprecated."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// @alova/vue-options@1.x\nexport default {\n  mixins: mapAlovaHook(function () {\n    return {\n      testRequest: useRequest(this.method)\n    };\n  }),\n\n  watch: mapWatcher({\n    'testRequest.data'() {\n    // ...\n    }\n  })\n}\n\n// @alova/vue-options@2.0\nexport default {\n  // ...\n  watch: {\n    'testRequest.data'() {\n      // ...\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"alovascene--optimization",children:"@alova/scene-* optimization"}),"\n",(0,t.jsxs)(n.p,{children:["We have optimized some strategies of ",(0,t.jsx)(n.code,{children:"@alova/scene-*"})," and moved them to ",(0,t.jsx)(n.code,{children:"alova/client"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"usepagination",children:"usePagination"}),"\n",(0,t.jsx)(n.h4,{id:"1-set-abortlast-to-true-by-default",children:"1. Set abortLast to true by default"}),"\n",(0,t.jsx)(n.p,{children:"When continuously turning pages or querying data, only the content of the last operation will be displayed, which is more in line with the experience."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x requires explicit settings\nusePagination({\n  // ...\n  abortLast: true\n});\n\n// 3.x does not require\nusePagination({\n  // ...\n});\n"})}),"\n",(0,t.jsx)(n.h4,{id:"optimize-the-use-under-react",children:"Optimize the use under react"}),"\n",(0,t.jsx)(n.p,{children:"Under react, the page and pageSize export items are no longer a reactState, and now update is used uniformly to change the state."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x\nconst {\n  page: [page, setPage],\n  pageSize: [pageSize, setPageSize]\n  /*...*/\n} = usePagination(/*...*/);\nconst handleAddPage = () => {\n  setPage(page + 1);\n};\nconst handleSetPageSize = newPageSize => {\n  setPageSize(newPageSize);\n};\n\n// 3.x\nconst { page, pageSize, update /*...*/ } = usePagination(/*...*/);\nconst handleAddPage = () => {\n  update({ page: page + 1 });\n};\nconst handleSetPageSize = newPageSize => {\n  update({ pageSize: newPageSize });\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"useform",children:"useForm"}),"\n",(0,t.jsx)(n.h4,{id:"1-no-longer-supports-directly-passing-in-id-to-return-cached-hookreturns",children:"1. No longer supports directly passing in id to return cached hookReturns"}),"\n",(0,t.jsxs)(n.p,{children:["Due to the original scene The package is directly divided into three packages: ",(0,t.jsx)(n.code,{children:"@alova/scene-react"}),", ",(0,t.jsx)(n.code,{children:"@alova/scene-vue"}),", and ",(0,t.jsx)(n.code,{children:"@alova/scene-svelte"}),". The export status of each package is fixed to the status type of the corresponding UI framework. After the revision, it is unified into a client library. When submitting a multi-step form, it is also necessary to provide a method instance or methodHandler to automatically infer which UI framework's status type should be exported, but the function remains unchanged."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// In 2.x, states are the state types of the corresponding UI framework\nconst states = useForm('form-id');\n\n// In 3.0, a method instance or methodHandler must also be provided\nconst { states, update } = useForm(formData => methodHandler(formData), {\n  // ...\n  id: 'form-id'\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"usesqrequest",children:"useSQRequest"}),"\n",(0,t.jsxs)(n.h4,{id:"1-updatestateeffect-no-longer-supports-the-use-of-method-matchers",children:["1. ",(0,t.jsx)(n.code,{children:"updateStateEffect"})," no longer supports the use of method matchers"]}),"\n",(0,t.jsxs)(n.p,{children:["Since updateState no longer supports the use of method matchers, ",(0,t.jsx)(n.code,{children:"updateStateEffect"})," is modified synchronously, and the ",(0,t.jsx)(n.code,{children:"onMatch"})," callback function is no longer supported."]}),"\n",(0,t.jsxs)(n.h4,{id:"2-modification-of-silentmethod-member-method-usage",children:["2. Modification of ",(0,t.jsx)(n.code,{children:"SilentMethod"})," member method usage"]}),"\n",(0,t.jsxs)(n.p,{children:["Since l2Cache can be set as an asynchronous function, ",(0,t.jsx)(n.code,{children:"SilentMethod.replace/remove/save"})," and ",(0,t.jsx)(n.code,{children:"filterSilentMethods/getSilentMethod"})," are changed from synchronous functions to asynchronous functions that return promises."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { filterSilentMethods, getSilentMethod } from 'alova/client';\n\nconst silentMethods = await filterSilentMethods('method-name', 'queue-name');\nconst silentMethod = await getSilentMethod('method-name', 'queue-name');\n\nawait silentMethod.replace(newSilentMethod);\nawait silentMethod.remove();\nawait silentMethod.save();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"accessaction",children:"accessAction"}),"\n",(0,t.jsx)(n.p,{children:"Added silent parameter, controlled by silent parameter, no error is thrown when delegation is not matched"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// Error is thrown when method-name is not matched\naccessAction('method-name', ({ send }) => {\n  send();\n});\n\n// No error is thrown at this time\naccessAction(\n  'method-name',\n  ({ send }) => {\n    send();\n  },\n  true\n);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"all-usehooks-force-function-is-changed-to-alovaevent-object",children:"All useHook's force function is changed to AlovaEvent object"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// @2.x\nuseRequest(Getter, {\n  force(arg1, arg2) {\n    // ...\n  }\n});\n\n// 3.x\nuseRequest(Getter, {\n  force(event) {\n    // Get args\n    const arg1 = event.args[0];\n    const arg2 = event.args[1];\n\n    // Get method\n    const method = event.method;\n  }\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"field-name-modification",children:"Field name modification"}),"\n",(0,t.jsxs)(n.h3,{id:"method__key__-is-simplified-to-methodkey",children:[(0,t.jsx)(n.code,{children:"method.__key__"})," is simplified to ",(0,t.jsx)(n.code,{children:"method.key"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x\nmethod.__key__ = 'custom-key';\n\n// 3.x\nmethod.key = 'custom-key';\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"methodtransformdata-is-simplified-to-methodtransform",children:[(0,t.jsx)(n.code,{children:"method.transformData"})," is simplified to ",(0,t.jsx)(n.code,{children:"method.transform"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x\nalova.Get('/api/profile', {\n  transformData(data) {\n    return data.detail;\n  }\n});\n\n// 3.x\nalova.Get('/api/profile', {\n  transform(data) {\n    return data.detail;\n  }\n});\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"methodlocalcache-changed-to-methodcachefor",children:[(0,t.jsx)(n.code,{children:"method.localCache"})," changed to ",(0,t.jsx)(n.code,{children:"method.cacheFor"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x\nalova.Get('/api/profile', {\n  localCache: 1000 * 60 * 60\n});\n\n// 3.x\nalova.Get('/api/profile', {\n  cacheFor: 1000 * 60 * 60\n});\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"all-sendargs-are-changed-to-args",children:["All ",(0,t.jsx)(n.code,{children:"sendArgs"})," are changed to ",(0,t.jsx)(n.code,{children:"args"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"onSuccess"})," and other events"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"force"})," function"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"In middleware function"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const { onSuccess } = useRequest(Getter, {\n  force(event) {\n    const args = event.args;\n  },\n  middleware(context, next) {\n    const args = context.args;\n    return next();\n  }\n});\nonSuccess(event => {\n  const args = event.args;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"alovaadapter-uniapp-export-name-change",children:"@alova/adapter-uniapp export name change"}),"\n",(0,t.jsxs)(n.p,{children:["Since alova's ",(0,t.jsx)(n.code,{children:"storageAdapter"})," was renamed to ",(0,t.jsx)(n.code,{children:"l2Cache"}),", the export item ",(0,t.jsx)(n.code,{children:"uniappStorageAdapter"})," of ",(0,t.jsx)(n.code,{children:"@alova/adapter-uniapp"})," was changed to ",(0,t.jsx)(n.code,{children:"uniappL2CacheAdapter"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"other-optimizations",children:"Other optimizations"}),"\n",(0,t.jsx)(n.h3,{id:"support-dependency-collection",children:"Support dependency collection"}),"\n",(0,t.jsxs)(n.p,{children:["This is a performance optimization. All useHooks in ",(0,t.jsx)(n.a,{href:"mailto:alova@3.x",children:"alova@3.x"})," will not update unaccessed states to reduce redundant view rendering caused by internal state updates."]}),"\n",(0,t.jsxs)(n.p,{children:["A simple example is as follows. When ",(0,t.jsx)(n.code,{children:"loading"})," is not used, ",(0,t.jsx)(n.code,{children:"useRequest"})," will not update the ",(0,t.jsx)(n.code,{children:"loading"})," state to reduce additional view rendering."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const App = () => {\n  const { data } = useRequest(method1);\n  return data ? <div>{data.name}</div> : null;\n};\n\nexport default App;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"middleware-optimization",children:"middleware optimization"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.a,{href:"mailto:alova@2.x",children:"alova@2.x"}),", accessing states data in middleware is not flexible enough because you get a framework-related state collection, which is not conducive to writing general middleware. Therefore, the following changes are made in 3.x:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Use the framework-independent proxyState to access and modify the state so that the middleware can be used in any UI framework."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"middleware({ proxyStates, args }, ({ update }) => {\n  // Access state\n  const loadingValue = proxyStates.loading.v;\n\n  // Modify state\n  proxyStates.loading.v = true;\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"all-event-binding-functions-return-their-own-objects",children:"All event binding functions return their own objects"}),"\n",(0,t.jsx)(n.p,{children:"In order to optimize the user experience and reduce renaming, all event binding functions return the export object of useHook to obtain the effect of chain call binding events."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 2.x\nconst { onSuccess, loading, data } = useRequest(method);\nonSuccess(event => {\n  // ...\n});\nconst { onSuccess: onSuccess2, error } = useRequest(method2);\nonSuccess2(event => {\n  // ...\n});\n\n// 3.x\nconst { loading, data } = useRequest(method).onSuccess(event => {\n  // ...\n});\nconst { error } = useRequest(method2).onSuccess(event => {\n  // ...\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,a)=>{a.d(n,{Z:()=>c,a:()=>r});var t=a(67294);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);