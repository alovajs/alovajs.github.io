"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[6740],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=l(a),p=r,m=h["".concat(c,".").concat(p)]||h[p]||d[p]||s;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(6010);const s="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,o),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>T});var n=a(7462),r=a(7294),s=a(6010),o=a(2466),i=a(6550),c=a(1980),l=a(7392),u=a(12);function d(e){return function(e){var t;return(null==(t=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:t.filter(Boolean))??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function h(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??d(a);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function p(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:a}=e;const n=(0,i.k6)(),s=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,c._X)(s),(0,r.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(n.location.search);t.set(s,e),n.replace({...n.location,search:t.toString()})}),[s,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,s=h(e),[o,i]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[c,l]=m({queryString:a,groupId:n}),[d,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,s]=(0,u.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:n}),g=(()=>{const e=c??d;return p({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);i(e),l(e),f(e)}),[l,f,s]),tabValues:s}}var g=a(2389);const y="tabList__CuJ",b="tabItem_LNqP";function v(e){let{className:t,block:a,selectedValue:i,selectValue:c,tabValues:l}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.o5)(),h=e=>{const t=e.currentTarget,a=u.indexOf(t),n=l[a].value;n!==i&&(d(t),c(n))},p=e=>{var t;let a=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;a=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;a=u[t]??u[u.length-1];break}}null==(t=a)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":a},t)},l.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:p,onClick:h},o,{className:(0,s.Z)("tabs__item",b,null==o?void 0:o.className,{"tabs__item--active":i===t})}),a??t)})))}function w(e){let{lazy:t,children:a,selectedValue:n}=e;const s=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function k(e){const t=f(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",y)},r.createElement(v,(0,n.Z)({},e,t)),r.createElement(w,(0,n.Z)({},e,t)))}function T(e){const t=(0,g.Z)();return r.createElement(k,(0,n.Z)({key:String(t)},e))}},5843:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(7462),r=(a(7294),a(3905)),s=a(4866),o=a(5162);const i={title:"Cache set and query",sidebar_position:90},c=void 0,l={unversionedId:"learning/cache-set-and-query",id:"learning/cache-set-and-query",title:"Cache set and query",description:"Some service interfaces support batch request data, which means that it is always composed of uncertain sets of response data. When we want to batch request data when initializing the page, and then only request a single piece of data in the interaction, it will cause caching Penetration problem.",source:"@site/docs/03-learning/09-cache-set-and-query.md",sourceDirName:"03-learning",slug:"/learning/cache-set-and-query",permalink:"/learning/cache-set-and-query",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/03-learning/09-cache-set-and-query.md",tags:[],version:"current",sidebarPosition:90,frontMatter:{title:"Cache set and query",sidebar_position:90},sidebar:"tutorialSidebar",previous:{title:"Actively Invalidate Response Cache",permalink:"/learning/invalidate-response-cache"},next:{title:"Update response status across pages/modules",permalink:"/learning/update-response-data-across-modules"}},u={},d=[{value:"Update static cache data",id:"update-static-cache-data",level:2},{value:"Dynamically set cache data",id:"dynamically-set-cache-data",level:2},{value:"Interrupt cache set",id:"interrupt-cache-set",level:2},{value:"cache query",id:"cache-query",level:2}],h={toc:d};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Some service interfaces support batch request data, which means that it is always composed of uncertain sets of response data. When we want to batch request data when initializing the page, and then only request a single piece of data in the interaction, it will cause caching Penetration problem."),(0,r.kt)("p",null,"For example, we need to obtain the todo list data by date. During initialization, a request obtains the data of 5 days from May 1 to 5, and then the user obtains the data of May 1 again during the operation. At this time, it will not Hit the data on May 1st when it was initialized, because the initialized data of 5 days is stored together instead of being cached separately. At this time, we can manually create a single response cache for the data of these 5 days, so that we can Solve the problem of cache penetration when a single data request is made."),(0,r.kt)("p",null,"As we mentioned in ",(0,r.kt)("a",{parentName:"p",href:"/learning/response-cache"},"cache mode"),", each cached data is saved with the method instance that sends the request as the key, so the method instance will also be used when updating the cache manually to find the corresponding cached data."),(0,r.kt)("h2",{id:"update-static-cache-data"},"Update static cache data"),(0,r.kt)(s.Z,{groupId:"framework",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"1",label:"vue",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  <button @click=\"handleTodolistToggle\">Switch date, hit cache</button>\n</template>\n<script setup>\n  import { setCache } from 'alova';\n  import { ref } from 'vue';\n\n  const getTodoListByDate = dateList =>\n    alovaInstance.Get('/todo/list/dates', {\n      params: { dateList }\n    });\n  // Get 5 days of data in batches during initialization\n  const dates = ref(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    //...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate(dates.value.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, the data of these 5 days will be cached together in a key\n    // In order to make subsequent requests for data of a certain day also hit the cache, we can disassemble the data of 5 days into days, and manually set the response cache successively through setCache\n    todoListDates.forEach(todoDate => {\n      // setCache parameter description:\n      // Parameter 1: method instance object, which is used to specify the key of the cache\n      // Parameter 2: Cache data\n      setCache(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this time, when the switching date is May 1, it will hit the response cache we manually set.\n    // The dates value is being monitored by useWatcher, so changing it can automatically trigger the request\n    dates.value = ['2022-05-01'];\n  };\n  // highlight-end\n<\/script>\n"))),(0,r.kt)(o.Z,{value:"2",label:"react",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { setCache } from 'alova';\nimport { useState } from 'react';\n\nconst getTodoListByDate = dateList =>\n  alovaInstance.Get('/todo/list/dates', {\n    params: { dateList }\n  });\n\nconst App = () => {\n  // Get 5 days of data in batches during initialization\n  const [dates, setDates] = useState(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    //...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate(dates.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, the data of these 5 days will be cached together in a key\n    // In order to make subsequent requests for data of a certain day also hit the cache, we can disassemble the data of 5 days into days, and manually set the response cache one by one through setCache\n    // The first parameter of setCache is the method instance object, which is used to specify the key of the cache\n    // The second parameter is the cached data\n    todoListDates.forEach(todoDate => {\n      setCache(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this time, when the switching date is May 1, it will hit the response cache we manually set.\n    // The dates value is being monitored by useWatcher, so changing it can automatically trigger the request\n    setDates(['2022-05-01']);\n  };\n  // highlight-end\n\n  return <button onClick={handleTodolistToggle}>Switch date, hit cache</button>;\n};\n"))),(0,r.kt)(o.Z,{value:"3",label:"svelte",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<script>\n  import { setCache } from 'alova';\n  import { writable } from 'svelte/store';\n\n  const getTodoListByDate = dateList =>\n    alovaInstance.Get('/todo/list/dates', {\n      params: { dateList }\n    });\n  // Get 5 days of data in batches during initialization\n  const dates = writable(['2022-05-01', '2022-05-02', '2022-05-03', '2022-05-04', '2022-05-05']);\n  const {\n    //...\n    onSuccess\n  } = useWatcher(() => getTodoListByDate($dates.join()), [dates], {\n    immediate: true\n  });\n  onSuccess(todoListDates => {\n    if (todoListDates.length <= 1) {\n      return;\n    }\n\n    // highlight-start\n    // By default, the data of these 5 days will be cached together in a key\n    // In order to make subsequent requests for data of a certain day also hit the cache, we can disassemble the data of 5 days into days, and manually set the response cache one by one through setCache\n    // The first parameter of setCache is the method instance object, which is used to specify the key of the cache\n    // The second parameter is the cached data\n    todoListDates.forEach(todoDate => {\n      setCache(getTodoListByDate(todoDate.date), [todoDate]);\n    });\n    // highlight-end\n  });\n\n  // highlight-start\n  const handleTodolistToggle = () => {\n    // At this time, when the switching date is May 1, it will hit the response cache we manually set.\n    // The dates value is being monitored by useWatcher, so changing it can automatically trigger the request\n    $dates = ['2022-05-01'];\n  };\n  // highlight-end\n<\/script>\n<button on:click=\"{handleTodolistToggle}\">Switch date, hit cache</button>\n")))),(0,r.kt)("h2",{id:"dynamically-set-cache-data"},"Dynamically set cache data"),(0,r.kt)("p",null,"You can also pass in a callback function in ",(0,r.kt)("inlineCode",{parentName:"p"},"setCache")," to dynamically calculate the cache data and return the cache data that needs to be updated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"setCache(getTodoListByDate('2022-10-01'), oldCache => {\n  // Return the data that needs to be cached\n  return {\n    ...oldCache,\n    expire: isAfter('2022-10-01', new Date())\n  };\n});\n")),(0,r.kt)("p",null,"Similarly, you can also dynamically find method instances through ",(0,r.kt)("a",{parentName:"p",href:"/next-step/method-instance-matcher"},"method instance matcher"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"setCache(\n  {\n    name: 'todoList',\n    filter: (method, index, ary) => {\n      return index < 5;\n    }\n  },\n  'newCache'\n);\n")),(0,r.kt)("h2",{id:"interrupt-cache-set"},"Interrupt cache set"),(0,r.kt)("p",null,"Sometimes you need to dynamically determine whether to update the cache. If no data is returned in the callback function of ",(0,r.kt)("inlineCode",{parentName:"p"},"setCache"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," is returned, the original cache data will not be updated at this time"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"setCache(getTodoListByDate('2022-10-01'), oldCache => {\n  const isExpired = isAfter('2022-10-01', new Date());\n  if (!isExpired) {\n    return; // interrupt cache update\n  }\n  return null; // update the cache to null\n});\n")),(0,r.kt)("h2",{id:"cache-query"},"cache query"),(0,r.kt)("p",null,"At the same time, we also provide a cache query method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { queryCache } from 'alova';\n\nconst cacheData = queryCache(getTodoListByDate('2022-10-01'));\n")),(0,r.kt)("p",null,"You can also dynamically find method instances via ",(0,r.kt)("a",{parentName:"p",href:"/next-step/method-instance-matcher"},"method instance matcher"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const cacheData = queryCache({\n  name: 'todoList',\n  filter: (method, index, ary) => {\n    return index < 5;\n  }\n});\n")))}p.isMDXComponent=!0}}]);